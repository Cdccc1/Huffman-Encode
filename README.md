# Huffman-Encode-API

Huffman Encoding ECNU DataStructure Project

此文档为项目API文档

[toc]

# 中文输出

```c++
// 设置locale为中文环境，只有这样才能测试时输出中文
    std::locale::global(std::locale("zh_CN.UTF-8"));
    std::wcout.imbue(std::locale());


    wcout << L"中文输出测试" << endl;
```



# FrequencyCounter

FrequencyCounter 类用于读取文件，统计字符频率，并将统计结果存储和输出。它能够读取文本文件，计算文件中每个字符的出现次数，并将这些信息写入到新文件中。

## **公共方法**

### **FrequencyCounter (构造函数)**
- **参数**:
    - 无参数版本: 初始化一个空的FrequencyCounter对象。
    - `const std::wstring& filename`: 需要计算字符频率的文件路径和名称。
- **功能**: 无参数版本构造函数初始化一个空的字符频率表。带参数的构造函数在创建FrequencyCounter实例时，立即计算指定文件的字符频率。

### **~FrequencyCounter (析构函数)**
- **功能**: 释放FrequencyCounter对象相关的资源。

### **countFrequency**
- **参数**:
    - `const std::wstring& filename`: 需要计算字符频率的文件路径和名称。
- **返回**: `std::map<std::wstring, int>` - 字符及其频率的映射表。
- **功能**: 读取指定的文件，并计算文件中每个字符的出现频率，结果存储于一个map中返回。

### **writeFrequency**
- **参数**:
    - `const std::wstring& outputFilename`: 需要写入字符频率结果的文件路径和名称。
- **功能**: 将已计算的字符频率表（frequencyTable）的内容写入到指定的文件中。每行包含一个字符及其对应的频率。

## **私有成员**

### **frequencyTable**
- **类型**: `std::map<std::wstring, int>`
- **描述**: 存储字符及其频率的映射表。每个字符都是一个宽字符串（因为可能是UTF-8字符），与其出现次数相关联。

## **注意事项**
- FrequencyCounter 类在处理文件时，会设置文件流以支持UTF-8编码的文本，以便正确处理多字节字符。
- 在使用此类之前，确保文件路径和文件本身是可访问的，以避免运行时错误。
- 当写入频率统计结果时，文件会被创建或覆盖，所以请确保提供的输出文件路径是正确的，且应用有相应的写权限。



# **PriorityQueue**

### **模板参数**
- **T**: 优先队列中存储的数据类型。

### **描述**
`PriorityQueue`类是一个模板类，实现了一个基本的优先队列数据结构。优先队列是一种特殊的队列，其中的每个元素都有一定的优先级，出队操作总是选择优先级最高（或最低，具体取决于实现）的元素。本实现中，元素T的默认比较方式决定了优先级（使用`<`运算符，较小值具有更高优先级）。

## **公有方法**

### **PriorityQueue()**

 构造函数，初始化为空的优先队列。



### **void push(T item)**: 

将新元素添加到优先队列中。该方法将新元素添加至内部堆的末尾，并执行向上调整以保持堆属性。



### **void pop()**: 移除优先队列顶部的元素。

该方法首先检查队列是否为空，然后将堆顶元素与最后一个元素交换，移除现在位于末尾的原堆顶元素，最后执行向下调整以保持堆属性。



### **T top() const**: 

返回优先队列顶部的元素，但不移除它。如果队列为空，则抛出异常。



### **bool isEmpty() const**: 

返回一个布尔值，指示优先队列是否为空。



### **size_t size() const**:

 返回优先队列中的元素数量。



## **私有方法**
- **void heapifyUp(int idx)**: 向上调整堆。给定一个元素的索引，该方法通过与其父节点比较并在必要时交换来向上调整该元素，直到恢复堆属性或元素到达堆顶。
- **void heapifyDown(int idx)**: 向下调整堆。给定一个元素的索引，该方法通过与其子节点比较并在必要时交换来向下调整该元素，直到恢复堆属性。
- **int parent(int idx) const**: 返回给定索引的父节点索引。
- **int leftChild(int idx) const**: 返回给定索引的左子节点索引。
- **int rightChild(int idx) const**: 返回给定索引的右子节点索引。

## **私有成员**
- **std::vector<T> heap**: 一个向量，用于存储堆的元素。

## **使用注意事项**
- 此实现的优先队列默认为最小堆，自定义类型注意重载`<`比较函数，即最小元素拥有最高优先级并首先被移除。
- 在使用`top`和`pop`方法之前，应检查优先队列是否为空，以避免抛出异常。
- 优先队列的性能特性依赖于内部使用的堆结构，特别是在插入和删除操作中。



# **HuffmanTree**

HuffmanTree 类用于建立哈夫曼树，并通过哈夫曼编码进行数据的压缩与解压缩。它使用字符频率统计来构建树，并提供编码和解码文本的方法。

## **公共方法**

### **HuffmanTree (构造函数)**
- **功能**: 初始化一个空的哈夫曼树对象，根节点为nullptr。

### **~HuffmanTree (析构函数)**
- **功能**: 释放哈夫曼树占用的资源，递归释放所有节点。

### **buildTree**
- **参数**:
    - `const std::map<std::wstring, int>& frequencies`: 字符及其频率的映射表。
- **功能**: 利用给定的字符频率统计结果构建哈夫曼树。使用优先队列（小根堆）来优化构建过程。

### **encode**
- **返回**: `std::map<wchar_t, std::wstring>` - 字符及其哈夫曼编码的映射表。
- **功能**: 生成并返回每个字符的哈夫曼编码，这些编码是通过遍历哈夫曼树并记录路径（左为'0'，右为'1'）来构建的。

### **decode**
- **参数**:
    - `const std::wstring& encodedStr`: 已编码的字符串。
- **返回**: `std::wstring` - 解码后的原始字符串。
- **功能**: 对已编码的字符串进行解码，恢复成原始文本。

## **私有方法**

### **encodeHelper**
- **参数**:
    - `Node* node`: 当前节点。
    - `std::wstring code`: 当前累积的编码路径。
    - `std::map<wchar_t, std::wstring>& codeMap`: 存储字符及其编码的映射表。
- **功能**: 递归辅助函数，用于遍历哈夫曼树并生成编码。

### **freeTree**
- **参数**:
    - `Node* node`: 当前节点。
- **功能**: 递归释放哈夫曼树中所有节点的内存。

## **私有成员**

### **root**
- **类型**: `Node*`
- **描述**: 指向哈夫曼树根节点的指针。

## **内嵌结构**

### **Node**
- **成员**:
    - `wchar_t character`: 存储的字符。
    - `int frequency`: 字符出现的频率。
    - `Node* left`: 指向左子节点。
    - `Node* right`: 指向右子节点。
- **功能**: 哈夫曼树的节点结构，用于存储字符、频率和子节点信息。
- **特点**: 重载了比较操作符，以便在优先队列中使用，使得频率高的节点被视为优先级低。

## **注意事项**
- 在使用此类之前，确保提供的字符频率统计信息准确无误。
- 构建树和编码过程可能会占用较多内存和时间，特别是对于大文本文件。
- 在使用析构函数释放内存时，应确保不会误删除未被本类管理的其他内存。



# Compressor

## **构造函数**
- **Compressor()**: 默认构造函数，初始化Compressor对象。
- **~Compressor()**: 析构函数，用于进行任何必要的清理。

## **公共方法**

### **compressFile**
- **参数**:
    - `const std::wstring& inputFilename`: 输入文件的路径和名称。
    - `const std::wstring& outputFilename`: 输出文件的路径和名称。
- **功能**: 读取指定的输入文件，进行压缩处理，然后将压缩结果输出到指定的输出文件。该方法依次调用私有方法计算字符频率、构建哈夫曼编码树以及执行实际的压缩操作。

## **私有方法**

### **countFrequency**
- **参数**:
    - `const std::wstring& inputFilename`: 输入文件的路径和名称。
- **功能**: 读取输入文件，并使用**`FrequencyCounter`**类统计文件中每个字符的出现频率。统计结果被存储在`frequencyTable`中，并将频率信息写入到一个新文件中。

### **buildCodes**
- **功能**: 基于`frequencyTable`中的字符频率信息构建哈夫曼编码树，并为每个字符生成唯一的哈夫曼编码。生成的编码存储在`codes`映射中。

### **compress**
- **参数**:
    - `const std::wstring& inputFilename`: 输入文件的路径和名称。
    - `const std::wstring& outputFilename`: 输出文件的路径和名称。
- **功能**: 执行实际的压缩过程。它首先读取输入文件的内容，并将每个字符转换成相应的哈夫曼编码，然后将编码后的二进制串写入输出文件中。该方法还处理文件打开和关闭以及错误检查。

## **私有成员**
- **std::map<std::wstring, int> frequencyTable**: 存储字符及其频率的映射表。
- **std::map<wchar_t, std::wstring> codes**: 存储字符及其哈夫曼编码的映射表。
- **HuffmanTree huffmanTree**: 哈夫曼树实例，用于构建编码。

## **注意事项**
- 该类设计用于文本文件压缩，使用哈夫曼编码方法。
- 请确保在调用`compressFile`之前输入和输出文件路径是有效的，以避免运行时错误。
- 类内部对异常进行了处理，但在使用时最好进行适当的错误处理。
